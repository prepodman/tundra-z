1. Напишите функцию `void swap(int * x, int * y) {}`, обменивающую две переменных. Проверьте ее работу.

2. Определите целочисленную переменную `size`, считайте ее значение с консоли с помощью `scanf()`. 
   
   Выделите с помощью `malloc()` целочисленный массив размером `size`. 

   1. Выведите на экран все элементы массива. Убедитесь, что массив содержит произвольные данные (т.е. неинициализирован).
   2. Замените `malloc` на `calloc`. Убедитесь, что память инициализируется нулями.
   3. Напишите циклы, которые выводят на экран какое-либо количество элементов за левым краем массива и за правым краем массива. 
      Добейтесь появления ошибки времени выполнения.
   4. Освободите выделенную память с помощью `free()`. 
      Попробуйте вывести на экран элементы  массива после его освобождения. Убедитесь, что это ведет к ошибке времени выполнения.
   5. Освободите память с помощью `free()` дважды. Убедитесь, что это ведет к ошибке времени выполнения.

3. Опытным путем определите максимальное количество памяти, которое может выделить операционная система за один вызов `calloc()`.
   Для этого, напишите цикл, который:

   * выделяет некоторое количество памяти и печатает сообщение вида «выделено xxx байт»;
   * Пробегается по выделенной памяти и записывает в нее произвольные значения.
     Убедитесь, что этот шаг необходим для чистоты эксперимента (если его пропустить, то память можно выделять бесконечно);
   * ожидает нажатия любой клавиши пользователем (`getchar()`);
   * освобождает память;
   * увеличивает размер выделяемой памяти в два раза. Не забудьте проверить указатель на `NULL` после `calloc`! 
     Понаблюдайте в диспетчере задач за потреблением памяти вашим процессом (`Ctrl+Shift+Esc` в ОС Виндоус, команда `top` в ОС Линукс).

4.  Напишите свою функцию `char * realloc(char * ptr, int size, int new_size){}`: функция получает указатель `ptr`, который указывает на `size` байт, выделяет новый кусок памяти размером `new_size`, копирует минимум из (`new_size`, `size`) элементов из `ptr` в новую память, освобождает `ptr`, возвращает указатель на новую память.

